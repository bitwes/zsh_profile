#!/usr/bin/ruby

def parse_line(line)
    parts = line.split("->")
    result = {
        :branch => parts[0],
        :remote => nil,
        :branch_name => nil,
        :upstream => parts[1],
        :upstream_hash => nil,
        :hash => parts[2],
        :possible_remote => nil,
    }

    branch_parts = result[:branch].split('/')
    if(branch_parts.size > 1)
        result[:remote] = branch_parts[0]
        result[:branch_name] = branch_parts[1]
    else
        result[:branch_name] = result[:branch]
    end
    # puts(result)
    return result
end


def parse_output(output)
    lines = output.split("\n")
    local_branches = []
    remote_branches = []
    both = []
    missing_upstream = []

    for i in 0..(lines.length() -1)
        result = parse_line(lines[i])
        if(result[:branch] == result[:branch_name])
            local_branches.append(result)
        else
            remote_branches.append(result)
        end
    end

    both, local_branches = local_branches.partition{|e| e[:upstream] != ""}
    for entry in both
        idx = remote_branches.find_index {|e| e[:branch_name] == entry[:branch_name]}
        if(idx != nil)
            entry[:upstream_hash] = remote_branches[idx][:hash]
            # print("remove this = #{remove_this}")
            remote_branches.delete_at(idx)
        end
    end


    for entry in local_branches
        in_remote = remote_branches.select {|b|
            b[:branch_name] == entry[:branch_name]
        }

        if(in_remote.size > 0)
            entry[:possible_remote] = in_remote[0]
            missing_upstream.append(entry)
        end
    end

    for entry in missing_upstream
        local_branches.delete_if { |i|
            # puts("     #{i[:branch_name]} == #{entry[:branch_name]}")
            i[:branch_name] == entry[:branch_name]
        }

        remote_branches.delete_if { |i|
            # puts("     #{i[:branch_name]} == #{entry[:branch_name]}")
            i[:branch_name] == entry[:branch_name]
        }
    end

    return {
        :both => both,
        :local_branches => local_branches,
        :remote_branches => remote_branches,
        :missing_upstream => missing_upstream
    }
end




def print_branches(branches)
    for branch in branches
        branch_str = branch[:branch].ljust(40)
        if(branch[:upstream_hash] != nil)
            branch_str += " #{branch[:hash]} #{branch[:upstream_hash]}"
        elsif(branch[:branch_name] == branch[:branch])
            branch_str += " #{branch[:hash]}"
        else
            branch_str += "         #{branch[:hash]}"
        end
        puts(branch_str)
        if(branch[:possible_remote] != nil)
            pr = branch[:possible_remote]
            puts("   ?#{pr[:branch]}".ljust(48) + " #{pr[:hash]}")
        end
    end
end


def print_parse_result(parse_result, option)
    title = "Branch".ljust(40) + " local   remote"
    puts(title)
    puts("".ljust(title.length, '-'))

    if(option == "remote")
        print_branches(parse_result[:both])
        print_branches(parse_result[:remote_branches])
    elsif(option == "remote_only")
        print_branches(parse_result[:remote_branches])
    elsif(option == "local_only")
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:local_branches])
    elsif(option == "local")
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:both])
        print_branches(parse_result[:local_branches])
    else
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:both])
        print_branches(parse_result[:local_branches])
        print_branches(parse_result[:remote_branches])
    end

end

def main
    cmd_result = `git branch --format "%(refname:short)->%(upstream)->%(tree:short)" -va`
    parse_result = parse_output(cmd_result)
    print_parse_result(parse_result, ARGV[0])
end


main()