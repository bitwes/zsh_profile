#!/usr/bin/ruby
require 'date'
require 'pp'


"""
this could be used to show remote branches that have been deleted:
git fetch -p --dry-run -v
"""

$delimeter = "->"

def parse_line(line)
    parts = line.split($delimeter)
    result = {
        :branch => parts[0],
        :upstream => parts[1],
        :hash => parts[2],
        :creatordate => Date.parse(parts[3]),

        :remote => nil,
        :branch_name => nil,
        :upstream_hash => nil,
        :possible_remote => nil,
    }

    branch_parts = result[:branch].split('/')
    if(branch_parts.size > 1)
        result[:remote] = branch_parts[0]
        result[:branch_name] = branch_parts[1]
    else
        result[:branch_name] = result[:branch]
    end

    if(result[:upstream] != '')
        result[:remote] = result[:upstream].split('/')[2]
    end

    return result
end


def parse_output(output)
    lines = output.split("\n")
    local_branches = []
    remote_branches = []
    both = []
    missing_upstream = []

    for i in 0..(lines.length() -1)
        result = parse_line(lines[i])
        if(result[:branch] == result[:branch_name])
            local_branches.append(result)
        else
            remote_branches.append(result)
        end
    end

    both, local_branches = local_branches.partition{|e| e[:upstream] != ""}
    for entry in both
        idx = remote_branches.find_index {|e| e[:branch_name] == entry[:branch_name]}
        if(idx != nil)
            entry[:upstream_hash] = remote_branches[idx][:hash]
            remote_branches.delete_at(idx)
        end
    end


    for entry in local_branches
        in_remote = remote_branches.select {|b|
            b[:branch_name] == entry[:branch_name]
        }

        if(in_remote.size > 0)
            entry[:possible_remote] = in_remote[0]
            missing_upstream.append(entry)
        end
    end

    for entry in missing_upstream
        local_branches.delete_if { |i|
            i[:branch_name] == entry[:branch_name]
        }

        remote_branches.delete_if { |i|
            i[:branch_name] == entry[:branch_name]
        }
    end

    return {
        :both => both,
        :local_branches => local_branches,
        :remote_branches => remote_branches,
        :missing_upstream => missing_upstream
    }
end


def print_branch(branch)
    branch_str = branch[:branch].ljust(40)
    hash_placeholder = "".ljust(branch[:hash].length)
    local_hash = hash_placeholder
    remote_hash = hash_placeholder
    hash_sep = "   "

    if(branch[:upstream_hash] != nil)
        local_hash = branch[:hash]
        remote_hash = branch[:upstream_hash]
    elsif(branch[:possible_remote] != nil)
        local_hash = branch[:hash]
        remote_hash = branch[:possible_remote][:hash]
        hash_sep = ' ~ '
    elsif(branch[:branch_name] == branch[:branch])
        local_hash = branch[:hash]
    else
        remote_hash = branch[:hash]
    end

    hash_indicator = '  '
    if(local_hash != hash_placeholder and remote_hash != hash_placeholder and local_hash != remote_hash)
        hash_indicator = '! '
    end

    remote_str = ""
    if(branch[:remote] != nil)
        remote_str = "(#{branch[:remote]})"
    elsif(branch[:possible_remote] != nil)
        # remote_str = 'asd;klfjas;dfljkads'
        remote_str = "(#{branch[:possible_remote][:branch].split('/')[0]})"
    end

    branch_str = branch_str.ljust(30) +
        hash_indicator + local_hash + hash_sep + remote_hash +
        " " + remote_str.ljust(15) +
        "  #{branch[:creatordate]}"

    puts(branch_str)
    # pp(branch)
end


def print_branches(branches)
    for branch in branches
        print_branch(branch)
    end
end


def print_parse_result(parse_result, option)
    title = "Branch".ljust(40) + " local      remote                   date       "
    puts(title)
    puts("".ljust(title.length, '-'))

    if(option == "remote")
        print_branches(parse_result[:both])
        print_branches(parse_result[:remote_branches])
    elsif(option == "remote_only")
        print_branches(parse_result[:remote_branches])
    elsif(option == "local_only")
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:local_branches])
    elsif(option == "local")
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:both])
        print_branches(parse_result[:local_branches])
    else
        print_branches(parse_result[:missing_upstream])
        print_branches(parse_result[:both])
        print_branches(parse_result[:local_branches])
        print_branches(parse_result[:remote_branches])
    end
end

# git branch --format \"%(refname:short)#{$delimeter}%(upstream)#{$delimeter}%(tree:short)#{$delimeter}%(creatordate)\" -va

def main
    cmd = "git branch --format \"%(refname:short)#{$delimeter}%(upstream)#{$delimeter}%(tree:short)#{$delimeter}%(creatordate)\" -va"
    cmd_result = `#{cmd}`
    # puts(cmd_result)
    parse_result = parse_output(cmd_result)
    print_parse_result(parse_result, ARGV[0])
end


main()